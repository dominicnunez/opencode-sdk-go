# Audit Exceptions

> Items validated as false positives or accepted as won't-fix.
> Managed by willie audit loop. Do not edit format manually.
>
> Entry format:
> ### Plain language description
> **Location:** `file/path:line` — optional context
> **Date:** YYYY-MM-DD
> **Reason:** Explanation (can be multiple lines)

## False Positives

<!-- Findings where the audit misread the code or described behavior that doesn't occur -->

### Response body read lacks timeout protection after request completes

**Location:** `internal/requestconfig/requestconfig.go:509,540`
**Date:** 2026-02-22

**Reason:** The audit claims body reads at lines 509 and 540 lack timeout protection, but this is incorrect. When `RequestTimeout` is set, a context with deadline is created (line 444) and passed to the cloned request (line 453). Go's HTTP transport sets a connection deadline based on this context deadline. Reading from `res.Body` uses the same connection and respects this deadline — if the deadline is exceeded during body read, the operation fails with a timeout error. The body read IS protected by the transport-level deadline mechanism.

### Inconsistent error message format for missing required parameters

**Location:** `session.go:54-55,74-75,86-87,98-99` and other service files
**Date:** 2026-02-22

**Reason:** The audit claims error messages are "inconsistent with the pattern used elsewhere" and suggests "some use 'received empty string' while others might use different phrasing." However, all 17 error messages for missing required parameters in the codebase follow the exact same format: `missing required parameter 'X' (received empty string)`. The audit provides no evidence of actual inconsistency and cannot cite any examples of different phrasing because none exist.

### GetBody error explicitly ignored in request body setup

**Location:** `internal/requestconfig/requestconfig.go:402,409`
**Date:** 2026-02-22

**Reason:** The GetBody closures at lines 401 and 405 are defined inline and cannot fail:
- Line 401 returns `io.NopCloser(bytes.NewReader(b)), nil` which always has nil error
- Line 408 calls `body.Seek(0, 0)` on a `*bytes.Reader` which cannot fail

The comparison to line 459 (where error is handled) is misleading because that's in the retry loop where GetBody could be any function, not the inline closures defined here.

### Magic numbers in retry delay calculation

**Location:** `internal/requestconfig/requestconfig.go:29-33`
**Date:** 2026-02-22

**Reason:** The values `maxRetryDelay = 8 * time.Second`, `initialDelayMultiplier = 0.5`, and `jitterDivisor = 4` are named constants with clear semantic names, not magic numbers. The audit conflates "lacks explanatory comment" with "magic number" - these are different concerns. Named constants are the standard solution for magic numbers.

### Redundant nil check in interface type assertion

**Location:** `option/requestoption.go:64-70`
**Date:** 2026-02-22

**Reason:** The audit title is factually incorrect - `if c, ok := client.(*http.Client); ok` is a type assertion, not a nil check. The "stale state" concern (else branch not clearing HTTPClient) doesn't affect behavior because `requestconfig.go:419-422` checks `if cfg.CustomHTTPDoer != nil` first, giving CustomHTTPDoer precedence. The code is consistent in practice.

### SSE buffer size integer overflow claim

**Location:** `packages/ssestream/ssestream.go:45`
**Date:** 2026-02-22

**Reason:** The audit claims `bufio.MaxScanTokenSize<<sseBufferMultiplier` (64KB << 9 = ~32MB) "could theoretically overflow on 32-bit systems." This is mathematically incorrect. The result is 33,554,432 bytes (~32MB), which is well under the 32-bit signed int maximum of 2,147,483,647 (~2.1GB). No overflow is possible.

## Won't Fix

<!-- Real findings not worth fixing — architectural cost, external constraints, etc. -->

### Named return values with naked returns in generated service code

**Location:** `client.go:47`, `config.go:34`, `agent.go:31`, `session.go:36` and similar patterns in other service files
**Date:** 2026-02-22

**Reason:** These files are auto-generated by the Stainless OpenAPI code generator. The named return values combined with naked returns are a stylistic choice of the generator. Modifying the generated code would require changing the Stainless generator template, which is an external tool. The pattern, while not idiomatic, does not cause bugs in practice for these simple factory functions.

### Path parameters not URL-encoded in generated service methods

**Location:** `session.go:58,78,90,102,114,126,138,154,166,178,190,202,214,226,238,250` and similar patterns in other service files
**Date:** 2026-02-22

**Reason:** These files are auto-generated by the Stainless OpenAPI code generator. Adding `url.PathEscape()` would require modifying the generator template, which is an external tool. The session IDs in this SDK are server-generated UUIDs that do not contain special characters, so path injection is not a practical concern for normal usage.

### httputil dump errors ignored in debugging methods

**Location:** `internal/apierror/apierror.go:44,46,51`
**Date:** 2026-02-22

**Reason:** The DumpRequest and DumpResponse methods are debugging utilities that return []byte. Adding error return values would be a breaking API change. For debugging purposes, returning empty output when the dump fails is acceptable behavior—the caller can inspect the returned bytes to determine if useful information was captured. Adding logging in library code is not idiomatic Go.

### http.DefaultClient used without default timeout

**Location:** `internal/requestconfig/requestconfig.go:174`
**Date:** 2026-02-22

**Reason:** The SDK intentionally uses http.DefaultClient as the default to give users full control over timeout behavior. Setting a default timeout could break existing code that relies on indefinite waits for long-running operations. Users can set a timeout via WithRequestTimeout(), WithHTTPClient(), or by passing a context with deadline. Documenting this is preferable to changing the default.

### Panics in library code for input validation and internal invariants

**Location:** `option/requestoption.go:103,106,262`, `internal/apiquery/encoder.go:265`, `internal/apijson/decoder.go:219`
**Date:** 2026-02-22

**Reason:** The remaining panics fall into two categories:

1. **Input validation** (`option/requestoption.go`): Panics for invalid `WithMaxRetries`/`WithTimeout` arguments. This is idiomatic Go for configuration functions where the caller has violated a documented contract. Similar to `regexp.MustCompile`.

2. **Internal invariants** (`apiquery/encoder.go:265`, `apijson/decoder.go:220`): These panics catch SDK maintainer errors during development (unknown ArrayFormat enum values, unregistered union types). They indicate bugs in the SDK itself, not user code. Failing fast helps catch these issues during development.

### Deprecated config fields still parsed

**Location:** `config.go:53-54,68,73-74,1058`
**Date:** 2026-02-22

**Reason:** The Config struct and its deprecated fields (autoshare, mode, layout) are generated from the OpenAPI spec. We cannot control what fields the spec defines. The deprecation comments are accurate and users should migrate, but removing the fields would break the generated code contract with the API.

### Global sync.Map for encoder/decoder caching grows unbounded

**Location:** `internal/apijson/decoder.go:18`, `internal/apijson/encoder.go:19`, `internal/apiquery/encoder.go:15`
**Date:** 2026-02-22

**Reason:** This is a standard caching pattern for reflection-based serialization. The cache is bounded by the number of distinct types used, which in practice is limited and stable for a given application. Memory profiling would be needed to demonstrate an actual problem before adding complexity like LRU eviction.

### Bytes buffer allocation in SSE hot path

**Location:** `packages/ssestream/ssestream.go:81`
**Date:** 2026-02-22

**Reason:** The `bytes.NewBuffer(nil)` call per event is a minor allocation in a streaming context. For typical usage patterns, the GC overhead is negligible. Using `sync.Pool` would add complexity for an optimization that would only benefit extremely high-throughput scenarios. No performance issue has been reported or measured.

## Intentional Design Decisions

<!-- Findings that describe behavior which is correct by design -->

### Debug middleware logs sensitive data

**Location:** `option/middleware.go:23-33`
**Date:** 2026-02-22

**Reason:** The `WithDebugLog` function is explicitly documented as "for debugging and development purposes only" and "should not be used in production." Users must explicitly opt-in by passing this middleware. Adding header redaction would add complexity for a debugging tool and could hide issues that debugging is meant to reveal.

### SSE stream error not returned directly

**Location:** `event.go:42-51`
**Date:** 2026-02-22

**Reason:** This is a standard pattern for streaming APIs in Go. The stream object must be returned so callers can iterate over events, and embedding the initial connection error in the stream allows a single return signature. The pattern is documented and callers are expected to check `stream.Err()` before iteration, similar to how database rows work.
